// Generated using `moon info`, DON'T EDIT IT
package "FlyCloudC/scheme"

import {
  "FlyCloudC/scheme/symbol",
  "FlyCloudC/scheme/tokenizer",
  "moonbitlang/core/hashmap",
}

// Values
pub let all_base_primitive : ReadOnlyArray[(@symbol.Symbol, Value)]

pub let number_primitive : ReadOnlyArray[(@symbol.Symbol, Value)]

pub let other_primitive : ReadOnlyArray[(@symbol.Symbol, Value)]

pub let pair_primitive : ReadOnlyArray[(@symbol.Symbol, Value)]

pub fn parse(StringView) -> Array[Value] raise ParseException

pub let string_primitive : ReadOnlyArray[(@symbol.Symbol, Value)]

pub let vector_primitive : ReadOnlyArray[(@symbol.Symbol, Value)]

// Errors
pub(all) suberror FromSexpError {
  FromSexpError(Value)
}
pub impl Show for FromSexpError

pub suberror ParseException {
  UnexpectedToken(@tokenizer.Token)
  MoreThanOneAfterDot(@tokenizer.Token)
  UnexpectedEndOfInput
  ReadException(@tokenizer.ReadException)
}
pub impl Show for ParseException

pub(all) suberror SchemeException {
  UndefineVar(@symbol.Symbol)
  CallNonProcedure
  ArgumentCount
  TypeError(Int)
  InvalidArgument(Int)
  DevideZero
}
pub impl Show for SchemeException

// Types and methods
pub struct Closure {
  env : Environment
  parm_names : FixedArray[@symbol.Symbol]
  body : Inst
  name : @symbol.Symbol?
}
pub impl Show for Closure

pub enum CoreForm {
  SelfEval(Value)
  Var(@symbol.Symbol)
  Quote(Value)
  Lambda(FixedArray[@symbol.Symbol], CoreForm)
  Begin(FixedArray[CoreForm], CoreForm)
  If(CoreForm, CoreForm, CoreForm?)
  Apply(CoreForm, FixedArray[CoreForm])
  Set(@symbol.Symbol, CoreForm)
  Define(@symbol.Symbol, CoreForm)
}
#as_free_fn
pub fn CoreForm::compile(Self) -> Inst
pub impl FromSexp for CoreForm
pub impl ToSexp for CoreForm
pub impl Show for CoreForm

pub(all) struct Environment {
  binds : @hashmap.HashMap[@symbol.Symbol, Value]
  next : Environment?
  closure : Closure?
}
pub fn Environment::base() -> Self
pub fn Environment::define_var(Self, @symbol.Symbol, Value) -> Unit
pub fn Environment::define_vars(Self, ReadOnlyArray[(@symbol.Symbol, Value)]) -> Unit
pub fn Environment::extend(Self, FixedArray[@symbol.Symbol], FixedArray[Value], Closure) -> Self
pub fn Environment::lookup(Self, @symbol.Symbol) -> Value raise SchemeException
pub fn Environment::set_var(Self, @symbol.Symbol, Value) -> Unit raise SchemeException
pub impl Show for Environment

pub struct Frame {
  ret : Inst
  env : Environment
  rib : FixedArray[Value]
  stack : Frame?
}

pub enum Inst {
  Const(Value, Inst)
  Refer(@symbol.Symbol, Inst)
  Return
  Close(FixedArray[@symbol.Symbol], Inst, @symbol.Symbol?, Inst)
  Branch(Inst, Inst)
  Save(Inst, Inst)
  Args(Int, Inst)
  Push(Int, Inst)
  Apply
  Set(@symbol.Symbol, Inst)
  Define(@symbol.Symbol, Inst)
}

pub(all) enum Primitive {
  Normal(name~ : @symbol.Symbol, (FixedArray[Value]) -> Value raise SchemeException)
  CallCC
  Apply
}
pub fn Primitive::name(Self) -> @symbol.Symbol
pub impl Show for Primitive

pub(all) struct VM {
  mut acc : Value
  mut next : Inst
  mut env : Environment
  mut rib : FixedArray[Value]
  mut stack : Frame?
}
pub fn VM::new(inst? : Inst, env? : Environment) -> Self
pub fn VM::run_one_step(Self) -> Unit raise SchemeException
pub fn VM::run_to_halt(Self) -> Unit raise SchemeException

pub(all) enum Value {
  Nil
  True
  False
  Pair(Value, Value)
  Int(Int)
  Double(Double)
  Symbol(@symbol.Symbol)
  String(String)
  Vector(FixedArray[Value])
  Primitive(Primitive)
  Closure(Closure)
  Continuation(Frame?)
}
pub fn Value::bool(Bool) -> Self
pub fn Value::eq(Self, Self) -> Bool
pub fn Value::list(FixedArray[Self]) -> Self
pub fn Value::list_tail_and_length(Self) -> (Self, Int)
pub fn Value::symbol(String) -> Self
pub fn Value::to_core_form(Self) -> CoreForm raise FromSexpError
pub fn Value::unsafe_to_fixedarray(Self, Int) -> FixedArray[Self]
pub impl ToSexp for Value
pub impl Default for Value
pub impl Eq for Value
pub impl Show for Value

// Type aliases

// Traits
pub(open) trait FromSexp {
  #as_free_fn
  from_sexp(Value) -> Self raise FromSexpError
}
pub impl FromSexp for Json

pub(open) trait ToSexp {
  #as_free_fn
  to_sexp(Self) -> Value
}
pub impl ToSexp for Bool
pub impl ToSexp for Int
pub impl ToSexp for Double
pub impl ToSexp for String
pub impl[A : ToSexp] ToSexp for FixedArray[A]
pub impl ToSexp for @symbol.Symbol
pub impl[A : ToSexp] ToSexp for Array[A]
pub impl[A : ToSexp, B : ToSexp] ToSexp for Iter2[A, B]
pub impl ToSexp for Json
pub impl[A : ToSexp, B : ToSexp] ToSexp for (A, B)

